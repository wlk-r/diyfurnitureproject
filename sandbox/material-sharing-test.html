<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PBR Material Sharing Test</title>
    <script type="module" src="https://ajax.googleapis.com/ajax/libs/model-viewer/3.5.0/model-viewer.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'IBM Plex Mono', monospace;
            font-size: 12px;
            background: #f7f5ee;
            padding: 20px;
            line-height: 1.6;
        }
        h1 { font-size: 14px; margin-bottom: 8px; }
        .subtitle { color: #666; margin-bottom: 20px; }
        h2 { font-size: 12px; margin: 20px 0 10px; text-transform: uppercase; letter-spacing: 0.05em; }

        .test-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 20px;
            margin-bottom: 24px;
        }

        .model-card {
            background: white;
            border: 1px solid #d8d2c6;
            padding: 16px;
        }

        .model-card h3 {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 8px;
        }

        .model-card.source { border-color: #2a9d2a; }
        .model-card.source h3::before { content: "● "; color: #2a9d2a; }

        model-viewer {
            width: 100%;
            height: 300px;
            background: #fafafa;
        }

        .status {
            margin-top: 12px;
            padding: 10px;
            background: #f5f5f5;
            font-size: 10px;
        }

        .status.success { background: #e8f5e9; }
        .status.pending { background: #fff3e0; }
        .status.error { background: #ffebee; }

        .controls {
            background: white;
            border: 1px solid #d8d2c6;
            padding: 16px;
            margin-bottom: 20px;
        }

        .controls button {
            background: #1f1f1f;
            color: white;
            border: none;
            padding: 10px 20px;
            cursor: pointer;
            font-family: inherit;
            font-size: 11px;
            margin-right: 8px;
            margin-bottom: 8px;
        }

        .controls button:hover { background: #333; }
        .controls button:disabled { background: #999; cursor: not-allowed; }

        .drop-zone {
            border: 2px dashed #ccc;
            padding: 30px;
            text-align: center;
            margin-bottom: 20px;
            background: white;
        }

        .drop-zone.dragover { border-color: #1f1f1f; background: #f5f5f5; }
        .drop-zone.source-drop { border-color: #2a9d2a; background: #f8fff8; }
        .drop-zone.source-drop.dragover { background: #e8f5e9; }
        .drop-zone input { display: none; }
        .drop-zone label { cursor: pointer; text-decoration: underline; }

        .info {
            background: white;
            border: 1px solid #d8d2c6;
            padding: 16px;
            margin-bottom: 20px;
        }

        .info code { background: #f0f0f0; padding: 2px 6px; }

        .info pre {
            background: #1f1f1f;
            color: #f0f0f0;
            padding: 16px;
            margin: 12px 0;
            overflow-x: auto;
            font-size: 11px;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 12px;
            margin-top: 16px;
            padding-top: 16px;
            border-top: 1px solid #eee;
        }

        .stat { text-align: center; }
        .stat-value { font-size: 18px; font-weight: 500; }
        .stat-label { font-size: 9px; text-transform: uppercase; color: #666; }

        .material-list {
            margin-top: 12px;
            font-size: 10px;
        }

        .material-item {
            padding: 8px;
            background: #f9f9f9;
            margin-bottom: 4px;
            display: flex;
            justify-content: space-between;
        }

        .material-item .name { font-weight: 500; }
        .material-item .channels { color: #666; }

        .hidden-viewer {
            /* Needs to be rendered (not off-screen) for model to load */
            width: 100px;
            height: 100px;
            border: 1px solid #ddd;
            opacity: 0.5;
            float: right;
            margin-left: 16px;
        }
    </style>
</head>
<body>
    <h1>PBR Material Sharing Test</h1>
    <p class="subtitle">Load materials from glTF/GLB source and apply to target models</p>

    <div class="controls">
        <h2>1. Load Material Source (glTF or GLB)</h2>
        <p style="margin-bottom: 12px; color: #666;">
            Drop a glTF folder (select all files including .gltf and textures) or a GLB file.
            Materials will be extracted with all PBR settings preserved.
        </p>

        <div class="drop-zone source-drop" id="sourceDropZone">
            <p><strong>Drop GLB file with materials</strong></p>
            <p style="font-size: 10px; color: #666; margin-top: 4px;">
                e.g., mat-plywood-00.glb containing "face" and "edge" materials
            </p>
            <p>or <label for="sourceFileInput">browse files</label></p>
            <input type="file" id="sourceFileInput" accept=".glb">
        </div>

        <div style="overflow: hidden;">
            <div id="hiddenContainer" class="hidden-viewer"></div>
            <div id="materialList" class="material-list"></div>
        </div>

        <div class="stats">
            <div class="stat">
                <div class="stat-value" id="statMaterials">0</div>
                <div class="stat-label">Materials</div>
            </div>
            <div class="stat">
                <div class="stat-value" id="statSourceSize">-</div>
                <div class="stat-label">Source Size</div>
            </div>
            <div class="stat">
                <div class="stat-value" id="statApplyTime">-</div>
                <div class="stat-label">Apply Time</div>
            </div>
            <div class="stat">
                <div class="stat-value" id="statApplied">0</div>
                <div class="stat-label">Applied</div>
            </div>
        </div>
    </div>

    <h2>2. Load Target Models (GLB)</h2>
    <div class="drop-zone" id="dropZone">
        <p>Drop GLB files (with matching material slot names)</p>
        <p>or <label for="fileInput">browse</label></p>
        <input type="file" id="fileInput" accept=".glb" multiple>
    </div>

    <div class="test-grid" id="modelGrid">
        <!-- Models added dynamically -->
    </div>

    <div class="info">
        <h2>How It Works</h2>
        <ol style="margin-left: 20px;">
            <li>Load a glTF/GLB that contains your materials (e.g., "face" and "edge" with full PBR textures)</li>
            <li>Materials are extracted with ALL settings: textures, normal scale, roughness, etc.</li>
            <li>Load target models that have materials with matching names (but no/placeholder textures)</li>
            <li>Source materials are cloned and applied, preserving all PBR properties</li>
        </ol>

        <h2>Recommended Workflow</h2>
        <pre>
In Blender:
1. Create material source file with "face" and "edge" materials
2. Export as glTF Separate (.gltf + .bin + textures)
   - This keeps textures as external files for browser caching
3. Export furniture models as GLB with same material names
   - Uncheck "Export Textures" to keep files small

File structure:
materials/
├── plywood.gltf           ← ~5KB JSON
├── plywood.bin            ← ~1KB geometry (if any)
├── face-diffuse.webp      ← Cached after first load
├── face-normal.webp
├── face-orm.webp
├── edge-diffuse.webp
├── edge-normal.webp
└── edge-orm.webp

models/
├── workbench.glb          ← ~100KB geometry only
├── table.glb
└── shelf.glb</pre>

        <h2>Why glTF with External Textures?</h2>
        <ul style="margin-left: 20px; margin-top: 8px;">
            <li><strong>Preserves settings:</strong> Normal map intensity, roughness values, etc.</li>
            <li><strong>Browser caching:</strong> Textures are separate files, cached after first load</li>
            <li><strong>Easy updates:</strong> Swap a texture without re-exporting the glTF</li>
            <li><strong>Smaller than GLB:</strong> glTF JSON is tiny, textures load separately</li>
        </ul>
    </div>


    <script type="module">
        // Extracted materials from source
        let sourceMaterials = {};
        let sourceViewer = null;
        let targetViewers = [];
        let totalSourceBytes = 0;

        const grid = document.getElementById('modelGrid');
        const materialListEl = document.getElementById('materialList');
        const hiddenContainer = document.getElementById('hiddenContainer');

        // Get Three.js scene from model-viewer
        function getThreeScene(viewer) {
            const symbols = Object.getOwnPropertySymbols(viewer);
            const sceneSymbol = symbols.find(s => s.description === 'scene');
            return sceneSymbol ? viewer[sceneSymbol] : null;
        }

        // Extract materials from source viewer
        function extractMaterials(viewer) {
            const scene = getThreeScene(viewer);
            if (!scene) {
                console.warn('[MATERIALS] Could not access scene');
                return {};
            }

            const materials = {};

            scene.traverse((node) => {
                if (node.isMesh && node.material) {
                    const mat = node.material;
                    const name = (mat.name || '').toLowerCase();

                    if (name && !materials[name]) {
                        materials[name] = mat;

                        // Log material details
                        const channels = [];
                        if (mat.map) channels.push('diffuse');
                        if (mat.normalMap) channels.push('normal');
                        if (mat.aoMap) channels.push('ao');
                        if (mat.roughnessMap) channels.push('rough');
                        if (mat.metalnessMap) channels.push('metal');

                        console.log(`[MATERIALS] Extracted "${name}":`, channels.join(', '));
                    }
                }
            });

            return materials;
        }

        // Update the materials list UI
        function updateMaterialsList() {
            const names = Object.keys(sourceMaterials);
            document.getElementById('statMaterials').textContent = names.length;

            if (names.length === 0) {
                materialListEl.innerHTML = '<p style="color:#666;">No materials extracted</p>';
                return;
            }

            materialListEl.innerHTML = names.map(name => {
                const mat = sourceMaterials[name];
                const channels = [];
                if (mat.map) channels.push('D');
                if (mat.normalMap) channels.push('N');
                if (mat.aoMap || mat.roughnessMap || mat.metalnessMap) channels.push('ORM');

                return `
                    <div class="material-item">
                        <span class="name">${name}</span>
                        <span class="channels">${channels.join(' + ') || 'no textures'}</span>
                    </div>
                `;
            }).join('');
        }

        // Apply source materials to a target viewer
        function applyMaterialsToViewer(viewer) {
            if (!viewer.model || Object.keys(sourceMaterials).length === 0) return [];

            const scene = getThreeScene(viewer);
            if (!scene) return [];

            let applied = [];

            scene.traverse((node) => {
                if (node.isMesh && node.material) {
                    const name = (node.material.name || '').toLowerCase();

                    if (sourceMaterials[name]) {
                        // Clone the source material
                        const clonedMat = sourceMaterials[name].clone();
                        clonedMat.name = name;

                        // Dispose old material
                        if (node.material.dispose) node.material.dispose();

                        node.material = clonedMat;
                        node.material.needsUpdate = true;

                        if (!applied.includes(name)) applied.push(name);
                    }
                }
            });

            if (applied.length > 0) {
                viewer.requestUpdate();
            }

            return applied;
        }

        // Apply materials to all targets
        function applyToAllTargets() {
            const startTime = performance.now();
            let totalApplied = 0;

            targetViewers.forEach(viewer => {
                const applied = applyMaterialsToViewer(viewer);
                totalApplied += applied.length;

                if (applied.length > 0) {
                    const statusEl = viewer.parentElement.querySelector('.status');
                    if (statusEl) {
                        statusEl.className = 'status success';
                        statusEl.innerHTML = `Applied: <strong>${applied.join(', ')}</strong>`;
                    }
                }
            });

            document.getElementById('statApplyTime').textContent = `${(performance.now() - startTime).toFixed(0)}ms`;
            document.getElementById('statApplied').textContent = totalApplied;
        }

        // ========== SOURCE FILE HANDLING ==========

        const sourceDropZone = document.getElementById('sourceDropZone');
        const sourceFileInput = document.getElementById('sourceFileInput');

        sourceDropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            sourceDropZone.classList.add('dragover');
        });

        sourceDropZone.addEventListener('dragleave', () => {
            sourceDropZone.classList.remove('dragover');
        });

        sourceDropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            sourceDropZone.classList.remove('dragover');
            handleSourceFiles(e.dataTransfer.files);
        });

        sourceFileInput.addEventListener('change', (e) => {
            handleSourceFiles(e.target.files);
        });

        async function handleSourceFiles(files) {
            totalSourceBytes = 0;
            const fileArray = Array.from(files);

            // Calculate total size
            fileArray.forEach(f => totalSourceBytes += f.size);

            // Check if it's a GLB or glTF
            const glbFile = fileArray.find(f => f.name.toLowerCase().endsWith('.glb'));
            const gltfFile = fileArray.find(f => f.name.toLowerCase().endsWith('.gltf'));

            if (glbFile) {
                // Simple GLB loading
                console.log('[MATERIALS] Loading GLB:', glbFile.name);
                await loadSourceFromBlob(glbFile);
            } else if (gltfFile) {
                // glTF with external files - need to create blob URLs for all
                await loadGltfWithExternals(gltfFile, fileArray);
            } else {
                alert('Please select a .gltf or .glb file');
            }
        }

        async function loadSourceFromBlob(file) {
            const url = URL.createObjectURL(file);
            await createSourceViewer(url, file.name);
        }

        async function loadGltfWithExternals(gltfFile, allFiles) {
            // Read the glTF JSON
            const gltfText = await gltfFile.text();
            let gltfJson = JSON.parse(gltfText);

            console.log('[GLTF] Processing glTF with', allFiles.length, 'files');

            // Create blob URLs for all external files
            const fileMap = {};
            allFiles.forEach(file => {
                if (file !== gltfFile) {
                    const url = URL.createObjectURL(file);
                    fileMap[file.name] = url;
                    const basename = file.name.split('/').pop().split('\\').pop();
                    fileMap[basename] = url;
                }
            });

            // Update buffer URIs
            if (gltfJson.buffers) {
                gltfJson.buffers.forEach(buffer => {
                    if (buffer.uri) {
                        const basename = buffer.uri.split('/').pop().split('\\').pop();
                        buffer.uri = fileMap[buffer.uri] || fileMap[basename] || buffer.uri;
                    }
                });
            }

            // Update image URIs
            if (gltfJson.images) {
                gltfJson.images.forEach(image => {
                    if (image.uri) {
                        const basename = image.uri.split('/').pop().split('\\').pop();
                        image.uri = fileMap[image.uri] || fileMap[basename] || image.uri;
                    }
                });
            }

            // Create blob URL for modified glTF
            const modifiedGltf = new Blob([JSON.stringify(gltfJson)], { type: 'model/gltf+json' });
            const gltfUrl = URL.createObjectURL(modifiedGltf) + '#.gltf';
            await createSourceViewer(gltfUrl, gltfFile.name);
        }

        async function createSourceViewer(url, filename) {
            // Clear previous
            hiddenContainer.innerHTML = '';
            sourceMaterials = {};

            // Wait for model-viewer custom element to be defined
            await customElements.whenDefined('model-viewer');

            // Create viewer using innerHTML so it initializes properly
            hiddenContainer.innerHTML = `
                <model-viewer
                    src="${url}"
                    camera-controls
                    auto-rotate
                    style="width: 200px; height: 200px;">
                </model-viewer>
            `;

            const viewer = hiddenContainer.querySelector('model-viewer');
            sourceViewer = viewer;


            // Update UI
            sourceDropZone.innerHTML = `
                <p><strong>Loaded:</strong> ${filename}</p>
                <p style="font-size: 10px; color: #666; margin-top: 4px;">
                    ${(totalSourceBytes / 1024).toFixed(1)}KB total
                </p>
                <p><label for="sourceFileInput">Click to replace</label></p>
                <input type="file" id="sourceFileInput" accept=".gltf,.glb,.bin,.webp,.jpg,.jpeg,.png" multiple>
            `;

            // Re-attach listener
            document.getElementById('sourceFileInput').addEventListener('change', (e) => {
                handleSourceFiles(e.target.files);
            });

            const sizeKb = (totalSourceBytes / 1024).toFixed(1);
            const sizeMb = (totalSourceBytes / (1024 * 1024)).toFixed(2);
            document.getElementById('statSourceSize').textContent =
                totalSourceBytes > 1024 * 1024 ? `${sizeMb}MB` : `${sizeKb}KB`;

            // Progress logging (commented out to reduce noise)
            // viewer.addEventListener('progress', (e) => {
            //     console.log('[MATERIALS] Loading progress:', e.detail?.totalProgress);
            // });

            let sourceLoadHandled = false;
            let pollInterval = null;

            function onSourceLoaded() {
                if (sourceLoadHandled) return;
                sourceLoadHandled = true;
                if (pollInterval) clearInterval(pollInterval);

                console.log('[MATERIALS] Source loaded');
                console.log('[MATERIALS] viewer.model:', viewer.model);

                sourceMaterials = extractMaterials(viewer);
                console.log('[MATERIALS] Extracted:', Object.keys(sourceMaterials));

                updateMaterialsList();

                // Auto-apply to existing targets
                if (targetViewers.length > 0) {
                    applyToAllTargets();
                }
            }

            viewer.addEventListener('load', () => {
                console.log('[MATERIALS] Load event fired');
                onSourceLoaded();
            });

            // Fallback: poll for model loaded state (in case load event doesn't fire)
            let pollCount = 0;
            pollInterval = setInterval(() => {
                pollCount++;

                const scene = getThreeScene(viewer);
                let meshCount = 0;
                if (scene) {
                    scene.traverse(n => { if (n.isMesh) meshCount++; });
                }

                console.log(`[MATERIALS] Poll ${pollCount}: model=${!!viewer.model}, scene=${!!scene}, meshes=${meshCount}`);

                if (viewer.model || meshCount > 0) {
                    console.log('[MATERIALS] Model ready via polling');
                    onSourceLoaded();
                }

                if (pollCount > 30) {
                    clearInterval(pollInterval);
                    console.warn('[MATERIALS] Source load timeout');
                    console.log('[MATERIALS] Final state - viewer:', viewer);
                    console.log('[MATERIALS] Final state - innerHTML:', hiddenContainer.innerHTML.substring(0, 200));
                }
            }, 500);

            viewer.addEventListener('error', () => {
                clearInterval(pollInterval);
                materialListEl.innerHTML = '<p style="color:#d32f2f;">Failed to load source</p>';
            });
        }

        // ========== TARGET MODELS ==========

        const dropZone = document.getElementById('dropZone');
        const fileInput = document.getElementById('fileInput');

        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropZone.classList.add('dragover');
        });

        dropZone.addEventListener('dragleave', () => {
            dropZone.classList.remove('dragover');
        });

        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropZone.classList.remove('dragover');
            handleTargetFiles(e.dataTransfer.files);
        });

        fileInput.addEventListener('change', (e) => {
            handleTargetFiles(e.target.files);
        });

        function handleTargetFiles(files) {
            for (const file of files) {
                if (file.name.toLowerCase().endsWith('.glb')) {
                    addTargetModel(file);
                }
            }
        }

        function addTargetModel(file) {
            const url = URL.createObjectURL(file);
            const id = `target-${Date.now()}-${Math.random().toString(36).substr(2, 5)}`;

            const card = document.createElement('div');
            card.className = 'model-card';
            card.innerHTML = `
                <h3>Target: ${file.name}</h3>
                <model-viewer
                    id="${id}"
                    src="${url}"
                    alt="${file.name}"
                    camera-controls
                    auto-rotate
                    shadow-intensity="1"
                    exposure="1">
                </model-viewer>
                <div class="status pending" id="${id}-status">Loading...</div>
            `;

            grid.appendChild(card);

            const viewer = card.querySelector('model-viewer');
            targetViewers.push(viewer);

            viewer.addEventListener('load', () => {
                let slots = [];
                const scene = getThreeScene(viewer);

                if (scene) {
                    scene.traverse((node) => {
                        if (node.isMesh && node.material) {
                            const name = (node.material.name || '').toLowerCase();
                            if (name && !slots.includes(name)) slots.push(name);
                        }
                    });
                }

                const statusEl = document.getElementById(`${id}-status`);
                statusEl.className = 'status';

                const slotIndicators = slots.map(s => {
                    const hasSource = !!sourceMaterials[s];
                    if (hasSource) {
                        return `<span style="color:#2a9d2a">${s} ✓</span>`;
                    }
                    return `<span style="color:#999">${s}</span>`;
                });

                statusEl.innerHTML = `Slots: <strong>${slotIndicators.join(', ') || 'none'}</strong>`;

                // Auto-apply if source is loaded
                if (Object.keys(sourceMaterials).length > 0) {
                    const applied = applyMaterialsToViewer(viewer);
                    if (applied.length > 0) {
                        statusEl.className = 'status success';
                        statusEl.innerHTML = `Applied: <strong>${applied.join(', ')}</strong>`;
                    }
                }
            });

            viewer.addEventListener('error', () => {
                const statusEl = document.getElementById(`${id}-status`);
                statusEl.className = 'status error';
                statusEl.textContent = 'Failed to load model';
            });
        }
    </script>
</body>
</html>
